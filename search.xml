<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>QT-TCP通讯</title>
      <link href="/2020/05/16/QT-TCP%E9%80%9A%E8%AE%AF/"/>
      <url>/2020/05/16/QT-TCP%E9%80%9A%E8%AE%AF/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h4 id="实现内容"><a href="#实现内容" class="headerlink" title="实现内容"></a>实现内容</h4><ul><li>多人聊天室</li><li>文件传输</li><li>多人语音聊天室</li></ul><h4 id="效果截图"><a href="#效果截图" class="headerlink" title="效果截图"></a>效果截图</h4><h5 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h5><p><img src="/.io//C:%5CUsers%5Clenovo%5CDesktop%5C123.png" alt="123"></p><h5 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h5><p><img src="/.io//C:%5CUsers%5Clenovo%5CDesktop%5C12.png" alt="12"></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><h5 id="服务器端-1"><a href="#服务器端-1" class="headerlink" title="服务器端"></a>服务器端</h5><p>注 pro文件需要添加</p><p><code>QT       += core gui network multimedia</code></p><h6 id="serverwidget-h"><a href="#serverwidget-h" class="headerlink" title="serverwidget.h"></a>serverwidget.h</h6><pre class=" language-QT"><code class="language-QT">#ifndef SERVERWIDGET_H#define SERVERWIDGET_H#include <QWidget>#include <QTcpServer>#include <QTcpSocket>#include <QVector>#include <QFile>#include <QTimer>//计时器#include <QAudio>//一下这五个是QT处理音频的库#include <QAudioFormat>#include <QAudioInput>#include <QAudioOutput>#include <QIODevice>QT_BEGIN_NAMESPACEnamespace Ui { class ServerWidget; }QT_END_NAMESPACEstruct people{    QString pip;    QString name;    int pport;};/*********************************************/const char file_flag = 'F';const char head_flag = 'H';const QString MSG_flag = "MSG##";const char sys_flag = '!';const char people_new = 'N';//新的用户到来  姓名传输过来const char to_c_people_new = 'P';//新的用户到来  传给客户端const char to_c_people_del = 'D';//新的用户离开  传给客户端/*********************************************/class ServerWidget : public QWidget{    Q_OBJECTpublic:    ServerWidget(QWidget *parent = nullptr);    ~ServerWidget();private slots:    void on_pushButton_clicked();    //    void on_ButtonSelect_clicked();    void on_ButtonSend_clicked();    void sendData(QTcpSocket* tcpSocket, int i);//发送文件数据    void onReadyRead();    void readyReadSlot();//receiveprivate:    Ui::ServerWidget *ui;    QTcpServer *tcpserver;//监听套接字    QVector<QTcpSocket *> socketarr;    int count = 0;    QFile  file[1024];//文件对象    QString fileName; //文件名字    QString filePath; //文件路径    qint64 fileSize;//文件大小    qint64 sendSize[1024];//已发送文件大小        QTimer timer[1024];//定时器  黏包  头部----文件体    QFile  file2;//文件对象    QString fileName2;//文件名字    qint64 fileSize2;//文件大小    qint64 recvSize2;//已发送文件大小    bool readyFile;    /*********************************************/    QVector<people> plist;    /*********************************************/    /*音频*/    QVector<QTcpSocket *> phonetcpsocket;    QTcpServer *phonetcpserver;    int phone_count=0;    QAudioInput *input;//音频采集    QIODevice   *inputDevice;//播放    QAudioOutput *output;    QIODevice   *outputDevice;protected:    void paintEvent(QPaintEvent *event);};struct video{    char audiodata[1024];    int lens;};#endif // SERVERWIDGET_H</code></pre><h6 id="serverwidget-cpp"><a href="#serverwidget-cpp" class="headerlink" title="serverwidget.cpp"></a>serverwidget.cpp</h6><pre class=" language-QT"><code class="language-QT">#include "serverwidget.h"#include "ui_serverwidget.h"#include <QFileDialog>//选择文件的对话框#include <QDebug>//用于debug#include <QFileInfo>//用于获取文件信息#include <QMap>#include <QStyleFactory>#include <QPainter>#include <QMessageBox>ServerWidget::ServerWidget(QWidget *parent)    : QWidget(parent)    , ui(new Ui::ServerWidget){    ui->setupUi(this);    resize(1000, 600);    tcpserver = NULL;    recvSize2 = 0;    readyFile = false;    tcpserver = new QTcpServer(this);   //监听套接字    ui->pushButton->setStyleSheet("background-color: rgb(175,238,238)");    ui->textEdit_online->setStyleSheet("background-color: rgba(255, 0, 255, 60)");    ui->textEdit->setStyleSheet("background-color: rgba(0, 255, 255, 60)");    ui->textEditFile->setStyleSheet("background-color: rgba(255, 0, 255, 60)");    ui->progressBar->hide();    for(int i=0;i<1024;i++)sendSize[i]=0;}void ServerWidget::paintEvent(QPaintEvent *){    QPainter p(this);    p.drawPixmap(0, 0, width(), height(), QPixmap("../src/b3.jpg"));}ServerWidget::~ServerWidget(){    delete ui;}//聊天室按钮void ServerWidget::on_pushButton_clicked(){    //获取端口号    if(ui->lineEdit->text()=="")return;    qint16 port = ui->lineEdit->text().toInt();    //监听    tcpserver->listen(QHostAddress::Any,port);    setWindowTitle("服务器："+ui->lineEdit->text());    ui->textEdit->setText("聊天室创建成功！");    //如果新进客户端与服务器连接，tcpServer会自动触发newConnection()    connect(tcpserver,&QTcpServer::newConnection,            [=]()                {                     count++;                     ui->labelonline->setText("当前在线人数："+QString::number(count));                     //取出socket                     QTcpSocket *socket;                     socket = tcpserver->nextPendingConnection();                     //加入数组                     socketarr.push_back(socket);                     QString ip = socket->peerAddress().toString();//取出ip                     ip = ip.right(ip.length()-7);    //删除前缀                     qint16 port = socket->peerPort();//取出端口                     /***********************************加入新的用户**************************************/                     people per;                     per.pip = ip;                     per.pport = port;                     per.name = "NULL";                     plist.push_back(per);                     /***********************************************************************************/                     //组包提示信息                     QString temp = QString("[%1%2]:进入聊天室").arg(ip).arg(port);                     ui->textEdit_online->append(ip);//增加显示当前所有的用户ip                     ui->textEdit->append(temp);                     temp = MSG_flag+temp;                     //广播新进用户                     for(int i=0;i<count;i++){                         socketarr[i]->write(temp.toUtf8().data());                     }                     connect(socket,&QTcpSocket::readyRead,                             [=]()                                {                                    //取内容                                    QByteArray byteBuf = socket->readAll();                                    QString buf =byteBuf;                                    if(readyFile)//接收文件信息                                    {                                        qint64 len = file2.write(byteBuf);                                        recvSize2 += len;                                        if(recvSize2 == fileSize2)                                        {                                           QString str = QString("收到文件：[%1: %2KB]").arg(fileName2).arg(fileSize2/1024);                                           file2.close();                                           QMessageBox::information(this,"文件信息",str);                                           recvSize2 = 0;                                           readyFile = false;                                        }                                        return;                                    }                                    if(buf[0]==people_new)                                    {                                        //取出ip                                        QString ip = socket->peerAddress().toString();//取出ip                                        //删除前缀                                        ip = ip.right(ip.length()-7);                                        qint16 port1 = socket->peerPort();//取出端口                                        QString thename;                                        for(int j=1;j<buf.size();j++){                                             thename[j-1] = buf[j];                                        }                                        for(int i=0;i<plist.size();i++){                                            if(plist[i].pip==ip && plist[i].pport == port1){                                                plist[i].name = thename;                                                                                     /**发给客户端*/                                                QString thestring;                                                thestring = to_c_people_new + plist[i].pip +sys_flag+ QString::number(plist[i].pport) + sys_flag + plist[i].name;                                                //P  ip  ! port ! name                                                for(int i=0;i<count;i++){                                                    socketarr[i]->write(thestring.toUtf8().data());                                                }                                                return;                                            }                                        }                                    }                                    else if(buf[0] == sys_flag)                                    {                                        //信息：                                        buf = buf.right(buf.length()-1); //去掉sys_flag                                        QString ip = socket->peerAddress().toString();//取出ip                                        qint16 port = socket->peerPort();//取出端口号                                        ip = ip.right(ip.length()-7); //删除ip前缀                                        //文件反馈信息                                        if(buf == "filedone"){                                           QString thetemp = QString(ip+":"+"文件已接收");                                           ui->textEditFile->append(thetemp);                                        }                                        else if(buf == "Close")//接收到用户端退出产生的反馈                                        {                                            /*******************************************************************************/                                            /********************************用户离开****************************************/                                            for(int i=0;i<plist.size();i++){                                                if(plist[i].pip==ip && plist[i].pport == port){                                                     /*发给客户端*/                                                     QString str;                                                     str = to_c_people_del + plist[i].pip +"!" + QString::number(plist[i].pport);                                                     //P  ip ! port                                                     for(int i=0;i<count;i++){                                                         socketarr[i]->write(str.toUtf8().data());                                                     }                                                     plist.remove(i);                                                     break;                                                }                                            }                                            /********************************************************************************/                                            for(int i=0;i<count;i++){                                                int iplen = socketarr[i]->peerAddress().toString().length()-7;                                                if(socketarr[i]->peerAddress().toString().right(iplen)==ip){                                                    QString temp = QString("[%1%2]:离开聊天室").arg(ip).arg(port);                                                    ui->textEdit->append(temp);                                                    temp = "MSG##"+temp;                                                    //广播出去                                                    for(int j=0;j<count;j++){                                                       socketarr[j]->write(temp.toUtf8().data());                                                    }                                                    //删除                                                    socketarr.remove(i);                                                    count--;                                                    ui->labelonline->setText("当前在线人数："+QString::number(count));                                                    break;                                               }                                            }                                            //在存在用户退出后，更新显示当前在线用户端ip                                            if(count==0)                                            {                                               ui->textEdit_online->setText("");                                            }                                            else                                            {                                                //显示首ip                                                QString ip = socketarr[0]->peerAddress().toString();//取出ip                                                //删除前缀！                                                ip = ip.right(ip.length()-7);                                                ui->textEdit_online->setText(ip);                                                //显示剩余ip                                                for(int i=1;i<count;i++)                                                {                                                QString ip = socketarr[i]->peerAddress().toString();//取出ip                                                //删除前缀！                                                ip = ip.right(ip.length()-7);                                                ui->textEdit_online->append(ip);                                                }                                            }                                       }                                    }                                    else if(buf.left(5) == MSG_flag)    //文本信息广播出去                                    {                                        QString temp1 = QString(buf);                                        ui->textEdit->append(temp1);                                        for(int i=0;i<count;i++){                                            socketarr[i]->write(temp1.toUtf8().data());                                        }                                    }                                    else if(buf[0] == head_flag)                                    {                                        fileName2 = buf.section("##",1,1);                                        fileSize2 = buf.section("##",2,2).toInt();                                        file2.setFileName("../files/"+fileName2);                                        bool isOk = file2.open( QFile::WriteOnly);                                        ui->textEditFile->append("收到文件：" + file2.fileName());                                        if(false == isOk)                                        {                                            QMessageBox::information(this,"文件信息","服务器炸了QWQ");                                            close();                                        }                                        readyFile = true;                                    }                                 }                             );                }    );    /**************************************************************************************/    //监听socket    phonetcpserver = new QTcpServer;    //receive    //qint16 phoneport = ui->lineEditphone->text().toInt();    phonetcpserver->listen(QHostAddress::Any,this->ui->lineEditphone->text().toInt());    connect(phonetcpserver,&QTcpServer::newConnection,           [=]()           {                QTcpSocket * thesocket;                thesocket = phonetcpserver->nextPendingConnection();//取出socket                QString ip = thesocket->peerAddress().toString();                int port = thesocket->peerPort();                ip = ip.right(ip.length()-7);                ui->textEdit->setText(QString("%1::%2-进入语音聊天室").arg(ip).arg(port));                //connect 一定要写在newConnection内                connect(thesocket,SIGNAL(readyRead()),this,SLOT(readyReadSlot()));//receiv  important                phonetcpsocket.push_back(thesocket);                phone_count++;    });    QAudioFormat format; //采样设置    format.setCodec("audio/pcm");//编码    format.setByteOrder(QAudioFormat::LittleEndian);    format.setSampleRate(8000);//采样评率    format.setSampleSize(16);//采样点数据位数    format.setSampleType(QAudioFormat::UnSignedInt);//返回采样点格式    format.setChannelCount(1);//音频数据通道数    input = new QAudioInput(format,this);//采用格式    inputDevice = input->start();//采集声音    output = new QAudioOutput(format,this);    outputDevice = output->start();//开始播放    connect(inputDevice,SIGNAL(readyRead()),this,SLOT(onReadyRead()));    /**************************************************************************************/}//选择文件按钮void ServerWidget::on_ButtonSelect_clicked(){    QString fPath = QFileDialog::getOpenFileName(this,"open","../");    if(false == fPath.isEmpty())//如果选择文件路径有效    {        //初始化        fileName.clear();        fileSize = 0;//        sendSize = 0;        filePath = fPath;        //获取文件信息        QFileInfo info(filePath);        fileName = info.fileName();        fileSize = info.size();    }    else    {        qDebug() << "选择文件路径出错 62";    }}void ServerWidget::on_ButtonSend_clicked(){    qDebug()<<"on_ButtonSend_clicked"<<endl;    //先发送文件头信息 文件名##文件大小    QString subhead = QString("%1##%2").arg(fileName).arg(fileSize);    QString head = head_flag + subhead;    //(广播)发送头部信息    for(int i=0;i<count;i++)    {        qint64 len = socketarr[i]->write(head.toUtf8());        if(len > 0)//头部信息发送成功        {            //发送真正的文件信息            //防止TCP黏包，需要通过定时器延时20ms            //文件传输计时器            connect(&timer[i],&QTimer::timeout,                    [=]()                    {                        //关闭定时器                        timer[i].stop();                        //发送文件                        sendData(socketarr[i], i);                    }                   );            timer[i].start(20);        }        else{            qDebug() << "头部信息发送失败 110";        }    }}void ServerWidget::sendData(QTcpSocket* tcpSocket, int i){    //指定文件名    file[i].setFileName(filePath);    //打开文件    bool isOk = file[i].open(QIODevice::ReadOnly);    if(false == isOk)    {        qDebug() << "只读方式打开文件失败 77";    }    //提示打开文件的路径    ui->textEditFile->append(filePath);    ui->progressBar->show();    ui->progressBar->setRange(0, fileSize);    ui->progressBar->setValue(0);    qint64 len = 0;    do    {        //每次发送数据的单位（缓冲区大小）        char buf[4 * 1024] = {0};        len = 0;        //往文件中读数据        len = file[i].read(buf,sizeof(buf));        //发送数据        len = tcpSocket->write(buf,len);        //发送的数据需要累积        sendSize[i] += len;        ui->progressBar->setValue(sendSize[i]);    }while(len > 0);    //判断是否发送文件完毕    if(sendSize[i] == fileSize)    {        sendSize[i] = 0;//以免重复弹出完成提示        ui->progressBar->hide();        file[i].close();        if(i==count-1)        QMessageBox::information(this,"文件信息","文件传输完毕");    }}/***********************************************************/void ServerWidget::onReadyRead(){    qDebug()<<"onReadyRead"<<endl;    /*----------------------------------send************************/        video vp;        memset(&vp,0,sizeof(vp));        //读取音频//        vp.lens = inputDevice->read(vp.audiodata,1024);//读取音频//        for(int j=0;j<phone_count;j++){//            phonetcpsocket[j]->write((const char*)&vp,sizeof(vp));//        }}void ServerWidget::readyReadSlot(){        qDebug() << "read" ;        int size = output->periodSize();        QByteArray bug;        qDebug()<<"audio is being received..."<<endl;        for(int k=0;k<phone_count;k++){            bug = phonetcpsocket[k]->readAll();            if(bug=="")continue;            for(int j=0;j<phone_count;j++){                if(k == j)  continue;                phonetcpsocket[j]->write(bug,size);            }        }}</code></pre><h6 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h6><pre class=" language-QT"><code class="language-QT">#include "serverwidget.h"#include <QApplication>#include <QStyleFactory>#include <QFile>int main(int argc, char *argv[]){    QApplication a(argc, argv);    a.setStyle(QStyleFactory::create("Fusion"));    ServerWidget w;    w.show();    return a.exec();}</code></pre><h5 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h5><p>注：pro文件添加</p><p><code>QT       += core gui network multimedia</code></p><h6 id="item-h"><a href="#item-h" class="headerlink" title="item.h"></a>item.h</h6><pre class=" language-QT"><code class="language-QT">#ifndef ITEM_H#define ITEM_H#include <QString>#include <QPushButton>#include <QWidget>#include <QHBoxLayout>#include <QTextEdit>class ITEM{private:    QTextEdit *msgbtn;    QPushButton *imgbtn;    QWidget *itw;    QHBoxLayout *hlayout;    QString name;    QString color;    QString align;    int fheight(const QString &str, int w);    int fwidth(const QString &str, int w);public:    ITEM(const QString &msg, const QString &name,const QString &ali , QWidget *w, QFont *f=NULL, bool vis=true);    void resize(int w, int h);    void setMsg(const QString &msg);    void setStyle(QFont *f, double r, double w, double h);    QWidget* Item();};#endif // ITEM_H</code></pre><h6 id="item-cpp"><a href="#item-cpp" class="headerlink" title="item.cpp"></a>item.cpp</h6><pre class=" language-QT"><code class="language-QT">#include "item.h"#include <QVBoxLayout>#include <cmath>using namespace std;int ITEM::fwidth(const QString &str, int w){    QFont f = msgbtn->font();    QFontMetrics fm(f);    QStringList sl = str.split('\n');    int ma=0;    for(auto s:sl)    {        if(ma < fm.boundingRect(s).width()+20)        {            ma = fm.boundingRect(s).width()+20;        }    }    return min(ma, int(0.6*w));}int ITEM::fheight(const QString &str, int w){    QFont f = msgbtn->font();    QFontMetrics fm(f);    QStringList sl = str.split('\n');    int res=12;    int h = fm.boundingRect(str).height();    for(auto s:sl)    {        res += h;        if(fm.boundingRect(s).width()+20 > int(0.6*w))        {            res += fm.boundingRect(s).width() / (int(0.6*w)-20) * h;        }    }    return max(res, 60);}ITEM::ITEM(const QString &msg, const QString &name, const QString &ali, QWidget *W,           QFont *f, bool vis){    align = ali;    itw = new QWidget(W);    hlayout = new QHBoxLayout();    itw->setLayout(hlayout);    QString btnMsg="  ";    for(int i=0, l=msg.length();i<l;i++)    {        if(msg[i] == '\n')        {            btnMsg.push_back("\n  ");        }        else        {            btnMsg.push_back(msg[i]);        }    }    btnMsg.push_back("  ");    msgbtn = new QTextEdit(itw);    msgbtn->setText(btnMsg);    msgbtn->setReadOnly(true);    imgbtn = new QPushButton(itw);    if(align == "left")    {        hlayout->addWidget(imgbtn);        hlayout->addWidget(msgbtn);        hlayout->addStretch();    }    else    {        hlayout->addStretch();        hlayout->addWidget(msgbtn);        hlayout->addWidget(imgbtn);    }    imgbtn->resize(25, 25);    if(f == NULL)    {        f = new QFont();        f->setFamily("微软雅黑");        f->setPixelSize(20);    }    msgbtn->setFont(*f);    QString alpha = "255";    if(!vis)    alpha="0";    if(name == "刘朝日")    {        this->name = "lzr.png";        this->color = "rgba(169,209,142,"+alpha+");";    }    else if(name == "刘硕")    {        this->name = "ls.png";        this->color = "rgba(255,217,102,"+alpha+");";    }    else if(name == "曹文豪")    {        this->name = "cwh.png";        this->color = "rgba(157,195,230,"+alpha+");";    }    else if(name == "刘涵准")    {        this->name = "lhz.png";        this->color = "rgba(102,204,255,"+alpha+");";    }    else if(name == "雷艳")    {        this->name = "ly.png";        this->color = "rgba(252,209,216,"+alpha+");";    }    imgbtn->setFixedSize(60, 60);    imgbtn->setStyleSheet("border-image:url(../src/"+ this->name +");"                          "border-radius:30px;");    msgbtn->setStyleSheet("background-color:"+this->color +                          "border-radius: 5px;"                          );    msgbtn->setMinimumHeight(60);    hlayout->setMargin(20);}void ITEM::resize(int w, int h){    msgbtn->setFixedSize(fwidth(msgbtn->document()->toPlainText(), w),                         fheight(msgbtn->document()->toPlainText(), w));    itw->resize(w, max(max(h, int(1.3*imgbtn->height())), int(1.3*msgbtn->height())));}void ITEM::setMsg(const QString &msg){    msgbtn->setText(msg);}QWidget* ITEM::Item(){    return itw;}</code></pre><h6 id="clientwidget-h"><a href="#clientwidget-h" class="headerlink" title="clientwidget.h"></a>clientwidget.h</h6><pre class=" language-QT"><code class="language-QT">#ifndef CLIENTWIDGET_H#define CLIENTWIDGET_H#include <QWidget>#include <QTcpSocket>//音频信息#include <QDialog>#include <QtNetwork/QUdpSocket>#include <QAudio>#include <QAudioInput>#include <QAudioOutput>#include <QIODevice>#include <QFile>#include <QDebug>#include <QMessageBox>//弹出对话框#include <QPushButton>#include <QTextEdit>#include <QVector>#include <QVBoxLayout>#include <QTimer>#include "item.h"QT_BEGIN_NAMESPACEnamespace Ui { class ClientWidget; }QT_END_NAMESPACEconst char file_flag = 'F';const char head_flag = 'H';const QString MSG_flag = "MSG##";const char sys_flag = '!';const char people_new = 'P';//新的用户到来const char people_del = 'D';//新的用户离开/***********************************************/struct people{    QString pip;    QString name;    QString pport;};/***********************************************/class ClientWidget : public QWidget{    Q_OBJECTpublic:    ClientWidget(QWidget *parent = nullptr);    ~ClientWidget();    void on_pushButtonenter_clicked();private slots:    void on_pushButtonsend_clicked();    void on_pushButtonclose_clicked();    void on_selectButton_clicked();    void on_sendButton_clicked();    void slider();    void readyReadSlot();    void onReadyRead();private:    Ui::ClientWidget *ui;    QVBoxLayout *vlayout;    QWidget *login;    QWidget *upload;    QString name, ip;    int port;    QVector<ITEM *> items;    int phone_port;    QVector<people> plist;    QTcpSocket *tcpsocket;    QFile  file;//文件对象    QString fileName;//文件名字    qint64 fileSize;//文件大小    qint64 recvSize;//已接收的文件大小    //客户端作为发送端    QFile  file2;//文件对象    QString fileName2;//文件名字    qint64 fileSize2;//文件大小    qint64 sendSize2;//已发送的文件大小    QTimer timer;//定时器  黏包  头部----文件体    QMessageBox msgBox;    bool phone_on;    bool fileflag;    bool readyFile;    void pushMsg(const QString &msg, const QString &name, const QString &alig);    void updateList();    //音频    QTcpSocket *phone_tcpsocket;    //out    QAudioOutput *output;    QIODevice *outputDevice;    //in    QAudioInput *input;    QIODevice *inputDevice;    bool linktophone=false;protected:    void sendData(QTcpSocket* tcpSocket);//发送文件数据    void paintEvent(QPaintEvent *event);signals:    void logined();};struct video{        char audiodata[1024];        int lens;    };#endif // CLIENTWIDGET_H</code></pre><h6 id="clientwidget-cpp"><a href="#clientwidget-cpp" class="headerlink" title="clientwidget.cpp"></a>clientwidget.cpp</h6><pre class=" language-QT"><code class="language-QT">#include "clientwidget.h"#include "ui_clientwidget.h"#include <QHostAddress>#include <QFileDialog>//选择文件的对话框#include <QPainter>#include <QInputDialog>#include <QWidget>#include <QScrollArea>#include <QFont>#include <QPushButton>#include <QTextEdit>#include <QAbstractSlider>#include <QScrollBar>#include <QLineEdit>#include <QDebug>#include <QProgressBar>#include <windows.h>#include <QRect>#include "item.h"ClientWidget::ClientWidget(QWidget *parent)    : QWidget(parent)    , ui(new Ui::ClientWidget){    phone_tcpsocket = new QTcpSocket;    ip="";    port = 0;    ui->setupUi(this);    ui->sendButton->hide();    ui->progressBar->hide();    readyFile = false;    phone_on = false;    setWindowTitle("计算机网络点点通信实验");    resize(1350, 850);    tcpsocket = NULL;    tcpsocket = new QTcpSocket(this);    connect(this, &ClientWidget::close, this, &ClientWidget::on_pushButtonclose_clicked);    ui->scrollArea->setStyleSheet("background-color:rgba(255,255,255,0)");    ui->input->setStyleSheet("background-color:rgba(255,255,0,20);"                             "border-style:solid;"                             "border-radius:5px;"                             "border-color:yellow;"                             "border-width:2.5px;");    QFont f;    f.setFamily("微软雅黑");    f.setPixelSize(20);    ui->input->setFont(f);    vlayout = new QVBoxLayout(ui->scrollAreaWidgetContents);    ui->scrollAreaWidgetContents->setLayout(vlayout);    vlayout->setDirection(QBoxLayout::BottomToTop);    vlayout->addStretch(100);    connect(ui->scrollArea->verticalScrollBar(), &QAbstractSlider::rangeChanged, this, &ClientWidget::slider);    upload = new QWidget();    login = new QWidget();    login->setWindowTitle("SOCKET 通信");    login->setFixedSize(300, 300);    QPushButton *namelabel = new QPushButton(login);    namelabel->setText("用户名");    namelabel->setGeometry(10,20, 60, 30);    QLineEdit *name = new QLineEdit(login);    name->setGeometry(80, 20, 200, 30);    QPushButton *iplabel = new QPushButton(login);    iplabel->setText("ip地址");    iplabel->setGeometry(10,70, 60, 30);    QLineEdit *ip = new QLineEdit(login);    ip->setGeometry(80, 70, 200, 30);    QPushButton *portlabel = new QPushButton(login);    portlabel->setText("port");    portlabel->setGeometry(10,120, 60, 30);    QLineEdit *port = new QLineEdit(login);    port->setGeometry(80, 120, 200, 30);    QPushButton *phoneportlabel = new QPushButton(login);    phoneportlabel->setText("p_port");    phoneportlabel->setGeometry(10,170, 60, 30);    QLineEdit *phoneport = new QLineEdit(login);    phoneport->setGeometry(80, 170, 200, 30);    phoneport->setText("10085");    QPushButton *loginbtn = new QPushButton(login);    loginbtn->setText("登录");    loginbtn->setGeometry(10, 220, 270, 40);    login->show();    connect(loginbtn, &QPushButton::pressed, this, [this, ip, port, name, phoneport](){        this->name = name->text();        this->ip = ip->text();        this->port = port->text().toInt();        this->phone_port = phoneport->text().toInt();        if(this->name != "刘朝日" && this->name != "曹文豪" && this->name != "刘硕" && this->name != "刘涵准"                && this->name != "雷艳")        {            return;        }        this->on_pushButtonenter_clicked();    });    connect(this, &ClientWidget::logined, login, &QWidget::close);    setMinimumSize(810, 510);    setMaximumSize(1350, 850);    ui->onlineListW->setStyleSheet("background-color:rgba(197,232,211,125);");    ui->progressBar->hide();    ui->selectButton->setStyleSheet("QPushButton{border-image:url(../src/upload.png);"                                    "border-radius:40px;}"                                    "QPushButton:hover{border-image:url(../src/upload_hover.png);"                                    "border-radius:40px;}");    ui->phoneButton->setStyleSheet("QPushButton{border-image:url(../src/phone_off.png);"                                     "border-radius:40px;}"                                   "QPushButton:hover{border-image:url(../src/phone_hover.png);"                                   "border-radius:40px;}");    connect(ui->phoneButton, &QPushButton::pressed, [=](){        if(phone_on)        {            ui->phoneButton->setStyleSheet("QPushButton{border-image:url(../src/phone_off.png);"                                             "border-radius:40px;}"                                           "QPushButton:hover{border-image:url(../src/phone_hover.png);"                                           "border-radius:40px;}");            phone_tcpsocket->close();        }        else        {            //获取服务器的ip和端口            //主动和服务器连接            phone_tcpsocket->connectToHost(this->ip, this->phone_port);            ui->phoneButton->setStyleSheet("QPushButton{border-image:url(../src/phone_on.png);"                                             "border-radius:40px;}"                                           "QPushButton:hover{border-image:url(../src/phone_onhover.png);"                                           "border-radius:40px;}");        }        phone_on = !phone_on;    });    //音频信息/*****************************************************************/        connect(phone_tcpsocket, &QTcpSocket::connected,        [=]()        {            //提示连接成功//            ui->textEdit->append("已经加入语音群聊");        }        );        connect(phone_tcpsocket,SIGNAL(readyRead()),this,SLOT(readyReadSlot()));        //设置参数        QAudioFormat format;        format.setSampleRate(8000);        format.setChannelCount(1);        format.setSampleSize(16);        format.setCodec("audio/pcm");        format.setSampleType(QAudioFormat::SignedInt);        format.setByteOrder(QAudioFormat::LittleEndian);        output = new QAudioOutput(format,this);        outputDevice = output->start();//开始播放        input = new QAudioInput(format,this);        inputDevice = input->start();        connect(inputDevice,SIGNAL(readyRead()),this,SLOT(onReadyRead()));//send        //音频信息/*****************************************************************/}void ClientWidget::paintEvent(QPaintEvent *){    QPainter p(this);    p.drawPixmap(0, 0, width(), height(), QPixmap("../src/background.jpg"));    ui->scrollArea->resize(0.75*width(), 0.87*height());    ui->scrollArea->move(0.25*width(), 0);    ui->input->resize(0.585*width(), 0.09*height());    ui->input->move(0.25*width(), 0.90*height());    ui->pushButtonsend->move(0.85*width(), 0.90*height());    ui->pushButtonsend->resize(0.14*width(), 0.04*height());    ui->pushButtonclose->move(0.85*width(), 0.95*height());    ui->pushButtonclose->resize(0.14*width(), 0.04*height());    ui->scrollAreaWidgetContents->resize(0.75*width(), 0.87*height());    ui->onlineListW->resize(0.25*width(), 0.87*height());    ui->onlineListW->move(0, 0);    ui->selectButton->resize(0.09*height(), 0.09*height());    ui->phoneButton->resize(0.09*height(),0.09*height());    ui->selectButton->move(0.03*width(), 0.90*height());    ui->phoneButton->move(0.18*width() , 0.90*height());}void ClientWidget::slider(){    ui->scrollArea->verticalScrollBar()->setValue(ui->scrollArea->verticalScrollBar()->maximumHeight());}void ClientWidget::updateList(){}ClientWidget::~ClientWidget(){    delete ui;}void ClientWidget::pushMsg(const QString &msg, const QString &name, const QString &ali){    ITEM *it = new ITEM(msg, name, ali, ui->scrollAreaWidgetContents);    vlayout->insertWidget(1, it->Item());    items.push_back(it);    it->resize(0.8*width(), 0.1*height());}void ClientWidget::on_pushButtonenter_clicked(){    //获取服务器的ip和端口    QString ip = this->ip;    qint16 port = this->port;    tcpsocket->connectToHost(QHostAddress(ip),port);    connect(tcpsocket,&QTcpSocket::connected,            [=]()            {                QString str = people_new+name;                tcpsocket->write(str.toUtf8().data());                emit logined();                show();            }            );    connect(tcpsocket,&QTcpSocket::readyRead,            [=]()                {                    //取出接收的内容                    QByteArray byteBuf = tcpsocket->readAll();                    if(byteBuf == "")   return;    //防止空串bug                    QString buf = byteBuf;                    if(readyFile)   //传过来的是文件                    {                        qint64 len = file.write(byteBuf);                        recvSize += len;                        if(recvSize == fileSize)                        {                            QString done;done.push_back(sys_flag);done.push_back("filedone");                            tcpsocket->write(done.toUtf8().data());                            file.close();                            QString str = QString("收到文件：[%1: %2KB]").arg(fileName).arg(fileSize/1024);                            readyFile = false;                            QMessageBox::information(this,"文件信息",str);                        }                    }                    else if(buf[0] == head_flag) //接收头                    {                        qDebug()<<buf<<endl;                        buf = buf.right(buf.length()-1);                        //解析头部信息 QString buf = "hello##1024"                        //初始化                        fileName = buf.section("##",0,0);                        fileSize = buf.section("##",1,1).toInt();                        recvSize = 0;                        //打开文件//                        QString filePath1 = QFileDialog::getExistingDirectory(this,"open","./");//                        qDebug()<<buf<<" "<<isMSG<<endl;//                        QString filePath1 = fileName;                        file.setFileName(fileName);//"D:\book\\"+                        qDebug()<<"收到文件：" + file.fileName()<<endl;                        bool isOk = file.open(QIODevice::WriteOnly);                        if(false == isOk)                        {                            QMessageBox::information(this,"文件信息","服务器炸了QWQ");                            close();                        }                        readyFile = true;                    }                    else if(buf[0]==people_new){//P  ip  ! port ! name                        QString theip ;                        QString theport;                        QString thename;                        int thej=1;                        int num=0;                        for(;thej<buf.size();thej++){                            if(buf[thej]==sys_flag)break;                            theip[num] = buf[thej];                        }                        thej++;                        num=0;                        for(;thej<buf.size();thej++){                            if(buf[thej]==sys_flag)break;                            theport[num] = buf[thej];                        }                        thej++;                        num=0;                        for(;thej<buf.size();thej++){                            thename[num] = buf[thej];                        }                        people thep;                        thep.pip = theip;                        thep.name = thename;                        thep.pport = theport;                        plist.push_back(thep);                        return;                    }                    else if(buf[0]==people_del){//D ip ! port                        QString theip ;                        QString theport;                        for(int j=1;j<buf.size();j++){                            if(buf[j]==sys_flag)break;                            theip[j-1] = buf[j];                        }                        bool flag = false;                        int num=0;                        for(int j=1;j<buf.size();j++){                            if(buf[j]!=sys_flag)continue;                            else {                                flag = true;                                continue;                            }                            if(flag){                                theport[num] = buf[j];                                num++;                            }                        }                        for(int i=0;i<plist.size();i++){                            if(plist[i].pip == theip && plist[i].pport == theport){                                plist.remove(i);                                return;                            }                        }                        return;                    }                    else if(buf.left(5) == MSG_flag)   //传过来的是信息                    {                        buf = buf.right(buf.length()-5);                        if(buf.section(":",1,1) == "进入聊天室")                        {                        }                        else if(buf.section(":",1,1) == "离开聊天室")                        {                        }                        else if(name != buf.section(":", 0, 0))                        {                            pushMsg(buf.section(":",1,1),buf.section(":", 0, 0) , "left");                        }                    }                }    );}void ClientWidget::on_pushButtonsend_clicked(){    //获取内容    QString str = ui->input->document()->toPlainText();    if(str == "")    {        QMessageBox::information(this,"提示","发送消息不能为空");        return;    }    pushMsg(str, name, "right");    str = MSG_flag+name+":"+str;    tcpsocket->write(str.toUtf8().data());    ui->input->clear();}void ClientWidget::on_pushButtonclose_clicked(){    //关闭    QString str;    str.push_back(sys_flag);    str.push_back("Close");    tcpsocket->write(str.toUtf8().data());    tcpsocket->disconnectFromHost();    tcpsocket->close();    this->close();}//选择文件按钮void ClientWidget::on_selectButton_clicked(){    QString filePath2 = QFileDialog::getOpenFileName(this,"open","../");    if(false == filePath2.isEmpty())//如果选择文件路径有效    {        //初始化        fileName2.clear();        fileSize2 = 0;        sendSize2 = 0;        //获取文件信息        QFileInfo info(filePath2);        fileName2 = info.fileName();        fileSize2 = info.size();        //只读方式打开文件        //指定文件名        file2.setFileName(filePath2);        //打开文件        bool isOk = file2.open(QIODevice::ReadOnly);        if(false == isOk)        {            qDebug() << "只读方式打开文件失败 77";            return;        }        upload->setWindowTitle("文件上传");        ui->progressBar->setValue(0);        ui->progressBar->setRange(0, fileSize2);        ui->progressBar->setParent(upload);        ui->progressBar->show();        ui->sendButton->setParent(upload);        ui->sendButton->show();        ui->progressBar->setGeometry(20, 20, 200, 50);        ui->sendButton->setGeometry(250, 20, 100, 50);        upload->show();    }    else    {        qDebug() << "选择文件路径出错 62";    }}//反向发送按钮void ClientWidget::on_sendButton_clicked(){    qDebug()<<"on_sendButton_clicked"<<endl;    //先发送文件头信息 文件名##文件大小    QString head = head_flag + QString("##%1##%2").arg(fileName2).arg(fileSize2);    qDebug()<<head<<endl;    //发送头部信息    qint64 len = tcpsocket->write(head.toUtf8());    if(len > 0)//头部信息发送成功    {        //发送真正的文件信息        //防止TCP黏包，需要通过定时器延时20ms        timer.start(200);        //文件传输计时器        connect(&timer,&QTimer::timeout,                [=]()                {                    //关闭定时器                    timer.stop();                    //发送文件                    sendData(tcpsocket);                }        );    }    else{        qDebug() << "头部信息发送失败 110";        file2.close();    }}//发送文件void ClientWidget::sendData(QTcpSocket* tcpSocket){    qint64 len = 0;    do    {        //每次发送数据的单位（缓冲区大小）        char buf[4 * 1024] = {0};        len = 0;        //往文件中读数据        len = file2.read(buf,sizeof(buf));        len = tcpSocket->write(buf,len);        //发送的数据需要累积        sendSize2 += len;        ui->progressBar->setValue(sendSize2);    }while(len > 0);    //判断是否发送文件完毕    if(sendSize2 == fileSize2)    {        QMessageBox::information(NULL, "transport", "文件发送完毕！");        ui->progressBar->hide();        sendSize2 = 0;//以免重复弹出完成提示    }    file2.close();    upload->close();}/*****************************音频信息*************************/void ClientWidget::readyReadSlot(){        int size = output->periodSize();        QByteArray bug;        video vp;        memset(&vp,0,sizeof(vp));        //监听音频   并且传送        qDebug()<<"我在接收呢"<<endl;        bug = phone_tcpsocket->readAll();        outputDevice->write(bug,size);}void ClientWidget::onReadyRead()//send{        qDebug()<<"It's sending audio!"<<endl;        video vp;        memset(&vp,0,sizeof(vp));        //读取音频        vp.lens = inputDevice->read(vp.audiodata,1024);        phone_tcpsocket->write((const char*)&vp,sizeof(vp));        //先给服务发送(接收文件完成的信息)}</code></pre><h6 id="main-cpp-1"><a href="#main-cpp-1" class="headerlink" title="main.cpp"></a>main.cpp</h6><pre class=" language-QT"><code class="language-QT">#include "clientwidget.h"#include <QApplication>#include <QStyleFactory>#include <QWidget>int main(int argc, char *argv[]){    QApplication a(argc, argv);    a.setStyle(QStyleFactory::create("Fusion"));    ClientWidget w;    return a.exec();}</code></pre><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><ul><li>仅仅支持同一局域网内通讯</li><li>若连接外网（比如河北的物理机）可以使用花生壳（免费1G）等端口映射工具；</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> QT </tag>
            
            <tag> 计网课设 </tag>
            
            <tag> TCP通讯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scanf 踩坑</title>
      <link href="/2020/05/14/scanf-%E8%B8%A9%E5%9D%91/"/>
      <url>/2020/05/14/scanf-%E8%B8%A9%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<p>scanf(“%c”,ch);这样会读入空格和回车符<br><img src="https://img-blog.csdnimg.cn/20200514173404162.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU1Mjk2MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">以下两种写法可以忽略回车符和空格</p><pre class=" language-cpp"><code class="language-cpp">cin<span class="token operator">>></span>ch<span class="token punctuation">;</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">" %c"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 程序设计 </tag>
            
            <tag> 错题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位运算</title>
      <link href="/2020/05/13/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
      <url>/2020/05/13/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p>查询状态S中是否有编号为 i 的点</p><pre class=" language-c++"><code class="language-c++">if(S & (1 << i)) return true;else return false;</code></pre><p>在状态 S 中添加编号为 i 的点</p><pre class=" language-c++"><code class="language-c++">S = S | (1 << i)</code></pre><p>在状态 S 中删除编号为 i 的点</p><pre><code>if(S &amp; (1 &lt;&lt; i))    S = S ^ (1 &lt;&lt; i);</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>To</title>
      <link href="/2020/05/11/T/"/>
      <url>/2020/05/11/T/</url>
      
        <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">birth</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="e946280ab40fff188d85531de34a60f1197e6bf2bcc4fa156c2a6895fd47db65">83cb0362696665ab864ce1998f50cdcae6e8f2204306c6924a163b5a3776530eb53fecbee382287f1e99bc758e2727fba7a2e376a53664fb8cd2fa66b2c52520433d39abba32aa2ce9769300c478e360dc31c502f71e741326e5228df41b4363eb5de9bbc295d31be4f179da09246c7cbf86e76d80cb7a747cddb20eddada5a350549cc82c85730bc518a030d5912b87bc0305be3772d9f0ee120f83b14fb2a960689dd93173b97f510e3228632b3b8994874b970bd550421f7a1e6ecde120401668c6bca566411856a8f7d476f5764bbbf9aaf761adeef5ae6860105cdd97f166f96307e1b5a64815d143432de6d097ca71d3686b1aa995cf26d88c39d3a1e6f856ef42da48da82c017dc865de2db69f26c2d1e25bc79a3bc97b10f6c10d3d63d6241d98df1ec6ecf3a72d16255042f355d9ee6201a073b0d69b3f0685d9e565592a2a7cb19abb7f7924c0b414e9ddc52feaa13d34606b19764d3c834a5c3352147d413c61f8dad7c1042d141fe729d785e44d55097b6cb6ea530e6de913011d338345574f33902b75b5d1260fa16adba51a6930f198b4252674903f61c39b69491dd8c7cadc66232887aef36fb9f6396cd06109ff7ff027c4a6704e3098607a77f6b52db730f99a3e5e33ae066d420229fbd0b8cc491261cb557654b14321e2f02dcbbc6e9c5fb594caa89d0ae44b041fff6793bf8d9a78677ac46b459eb5f629bb6ac22fa41fda00fc45756d04a3960bbc9bd11063f7da22f38de3a48e7ae725071aa206d32bdf6486a5de9f0a0793b2412e6c16ebf5256b1824c204ac23a5647403f91d239861b0720638c4d2340111b31c554642a4ef5a90ed50049d21b67622bcd23e573934a98df1e892b5b42f290e8a70d84dd785ec106bd8e2d4c1c8bdde1ef9f1ccd8caacf926b726b2fdd7b76fd6f45b8b869b085dd873da4e8759b4b2f249f8d9ab70de01c32fc58f08260f152fb31acfb60e570bb282115c176</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>随记</title>
      <link href="/2020/05/11/%E9%9A%8F%E8%AE%B0/"/>
      <url>/2020/05/11/%E9%9A%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h6 id="2020-05-11-晴"><a href="#2020-05-11-晴" class="headerlink" title="2020/05/11  晴"></a>2020/05/11  晴</h6><p>月下长饮一杯酒，怀念被写到泪流。月下卷入一莫愁，过往被写到泪流</p><h6 id="2020-05-14-小雨"><a href="#2020-05-14-小雨" class="headerlink" title="2020/05/14   小雨"></a>2020/05/14   小雨</h6><p>浮生有梦三千场，穷尽千里诗酒荒</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 随记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>书籍清单</title>
      <link href="/2020/05/11/%E4%B9%A6%E7%B1%8D%E6%B8%85%E5%8D%95/"/>
      <url>/2020/05/11/%E4%B9%A6%E7%B1%8D%E6%B8%85%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<h6 id="Done"><a href="#Done" class="headerlink" title="Done"></a>Done</h6><p>大一上：NULL</p><p>大一下：</p><p>你只是假装很努力   √</p><p>三毛，上天独宠的追梦人  √</p><p>梦里花落知多少  √</p><p>雨季不再来  √</p><p>我们仨  √</p><p>天才在左疯子在右  √</p><p>追风筝的人  √</p><p>明朝那些事  √</p><p>孝经  √</p><p>大二：</p><p>许三观卖血记  √</p><p>人间失格  √</p><p>活着  √</p><p>了凡四训  √</p><p>你今天真好看  √</p><p>谁动了我的奶酪  √</p><p>大二</p><h6 id="Will"><a href="#Will" class="headerlink" title="Will"></a>Will</h6><p>摆渡人 ing</p><p>阿勒泰的角落 </p><p>瓦尔登湖</p><p>静静的顿河</p><p>偷影子的人</p><p>杀死一只知更鸟</p><p>鲁迅文集</p><p>云边有个小卖部</p><p><img src="/.io//C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200512090808739.png" alt="image-20200512090808739"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 书籍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>待看电影清单</title>
      <link href="/2020/05/10/%E5%BE%85%E7%9C%8B%E7%94%B5%E5%BD%B1%E6%B8%85%E5%8D%95/"/>
      <url>/2020/05/10/%E5%BE%85%E7%9C%8B%E7%94%B5%E5%BD%B1%E6%B8%85%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<h1 id="电影清单"><a href="#电影清单" class="headerlink" title="电影清单"></a>电影清单</h1><p>可爱的骨头</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电影 </tag>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DP</title>
      <link href="/2020/05/10/%E5%8C%BA%E9%97%B4DP/"/>
      <url>/2020/05/10/%E5%8C%BA%E9%97%B4DP/</url>
      
        <content type="html"><![CDATA[<h1 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h1><p>什么是区间DP？</p><p>线性动态规划的一种扩展</p><p>在区间上进行的DP，通常是将大区间分割成小区间进行DP</p><p>在分阶段划分问题时，与阶段中元素出现的顺序和由前一阶段的哪写元素合并过来有很大关系</p><p>常见的转移方程类型</p><p><img src="/.io//C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200510160243296.png" alt="image-20200510160243296"></p><h4 id="题目：：："><a href="#题目：：：" class="headerlink" title="题目：：："></a>题目：：：</h4><p><a href="https://blog.csdn.net/mengxiang000000/article/details/73610401" target="_blank" rel="noopener">https://blog.csdn.net/mengxiang000000/article/details/73610401</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>踩坑</title>
      <link href="/2020/05/10/%E8%B8%A9%E5%9D%91/"/>
      <url>/2020/05/10/%E8%B8%A9%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h1 id="错题整理"><a href="#错题整理" class="headerlink" title="错题整理"></a>错题整理</h1><p>1、注意数据范围，long long 10^18</p><p>2、注意行末空格问题</p><p>3、字符读入的换行问题</p><p><img src="/.io//C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200510151447168.png" alt="image-20200510151447168"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 程序设计 </tag>
            
            <tag> 错题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL_map</title>
      <link href="/2020/05/10/STL-map/"/>
      <url>/2020/05/10/STL-map/</url>
      
        <content type="html"><![CDATA[<h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>map的基本操作函数：<br>   C++ Maps是一种关联式容器，包含“关键字/值”对<br>   begin()     返回指向map头部的迭代器<br>   clear(）     删除所有元素<br>   count()     返回指定元素出现的次数<br>   empty()     如果map为空则返回true<br>   end()       返回指向map末尾的迭代器<br>   equal_range()  返回特殊条目的迭代器对<br>   erase()     删除一个元素<br>   find()      查找一个元素<br>   get_allocator() 返回map的配置器<br>   insert()     插入元素<br>   key_comp()    返回比较元素key的函数<br>   lower_bound()  返回键值&gt;=给定元素的第一个位置<br>   max_size()    返回可以容纳的最大元素个数<br>   rbegin()     返回一个指向map尾部的逆向迭代器<br>   rend()      返回一个指向map头部的逆向迭代器<br>   size()      返回map中元素的个数<br>   swap()      交换两个map<br>   upper_bound()   返回键值&gt;给定元素的第一个位置<br>   value_comp()   返回比较元素value的函数</p><h2 id="count函数"><a href="#count函数" class="headerlink" title="count函数"></a>count函数</h2><p>返回的是被查找元素的个数。如果有，返回1；否则，返回0。注意，map中不存在相同元素，所以返回值只能是1或0。</p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>  map&lt;int ,string&gt; maplive;<br>  1.maplive.insert(pair&lt;int,string&gt;(102,”aclive”));<br>  2.maplive.insert(map&lt;int,string&gt;::value_type(321,”hai”));<br>  3, maplive[112]=”April”;//map中最简单最常用的插入添加！</p><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><pre class=" language-c++"><code class="language-c++">map<string,int>::iterator iter;//定义一个迭代指针iterfor(iter=M.begin(); iter!=M.end(); iter++)cout<<iter->first <<"->"<<iter->second<<endl;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> STL </tag>
            
            <tag> map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>观《美人鱼》有感</title>
      <link href="/2020/05/09/%E8%A7%82%E3%80%8A%E7%BE%8E%E4%BA%BA%E9%B1%BC%E3%80%8B%E6%9C%89%E6%84%9F/"/>
      <url>/2020/05/09/%E8%A7%82%E3%80%8A%E7%BE%8E%E4%BA%BA%E9%B1%BC%E3%80%8B%E6%9C%89%E6%84%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="2020-05-09"><a href="#2020-05-09" class="headerlink" title="2020/05/09"></a>2020/05/09</h2><p>没看之前，一直以为是搞笑无厘头电影。</p><p>但是呢，在观影过程中星爷一直在向我们传递以下两种观点：</p><p>  1、提倡保护生态</p><p>  2、 反对“金钱至上”</p><blockquote><p> 突然想到一个点，插播一下，特别郁闷：为什么一部电影的精髓部分，像这个的生态、金钱至上论啊，这种反而倒是成为不了人们的饭后谈资，倒是一些搞笑无厘头的地方容易被称之为所谓的“名场面”。</p></blockquote><p>下面是看到的精彩的评论</p><p>场景:</p><p>若兰和刘轩在泳池见面，为了驱赶刘轩身边女孩们，将一块手表抛出并说谁拿到给谁。</p><p>映射:</p><p>女孩们并不认识手表的价值一普通 人不知道什么东西是真的值钱。</p><p>刘轩说这手表也就值800万一”也就” 表现了人拥有更多财富后对价值的藐视。</p><p>女孩们得知价值后都去抢手表了一普通人的对既得利益的总是， 以及随大流的盲从。</p><p>刘轩评价道“她们都是为了赚钱努力奋斗的年青人”一拥有特权的幸幸者对 “商品拜物主义”的认可。</p><blockquote><p>看到这位的评论，我突然想到高中做的语文阅读理解。hhhhhhhhhhhhhhh</p></blockquote><h2 id="触发其他的想法"><a href="#触发其他的想法" class="headerlink" title="触发其他的想法"></a>触发其他的想法</h2><p>有时候我总是感觉一直在忙碌，很少有时间停下来思考。</p><blockquote><p>以前我会觉得，看一部电影，哎，要1个多小时，会感觉不如去看会书什么什么的。其实不会，它也会带来别样的深思</p></blockquote><p>于是，知乎搜了一下“做什么是浪费时间”</p><p><img src="/.io//C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200509225759666.png" alt="image-20200509225759666"></p><p>偶然想起，24枚金币时间管理法的创始人，艾力。</p><p>无限的刷微博、刷朋友圈、自己给自己点个赞。一分一秒流逝后，又剩下什么呢？</p><blockquote><p>所以，在一段时间之后，你再也想不起你做过什么，到底带来了什么，这样的事情应该是无意义的事情吧</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 日记 </tag>
            
            <tag> 影评 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后缀树(Ukkonen算法)</title>
      <link href="/2020/05/09/%E5%90%8E%E7%BC%80%E6%A0%91-Ukkonen%E7%AE%97%E6%B3%95/"/>
      <url>/2020/05/09/%E5%90%8E%E7%BC%80%E6%A0%91-Ukkonen%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="后缀树"><a href="#后缀树" class="headerlink" title="后缀树"></a>后缀树</h1><h5 id="可视化网站"><a href="#可视化网站" class="headerlink" title="可视化网站"></a><a href="https://brenden.github.io/ukkonen-animation/" target="_blank" rel="noopener">可视化网站</a></h5><h5 id="参考链接1–理论部分"><a href="#参考链接1–理论部分" class="headerlink" title="参考链接1–理论部分"></a><a href="https://www.cnblogs.com/xubenben/p/3484988.html" target="_blank" rel="noopener">参考链接1–理论部分</a></h5><h5 id="参考链接2–实操部分"><a href="#参考链接2–实操部分" class="headerlink" title="参考链接2–实操部分"></a><a href="https://www.cnblogs.com/xubenben/p/3486007.html" target="_blank" rel="noopener">参考链接2–实操部分</a></h5><h2 id="什么是后缀树？"><a href="#什么是后缀树？" class="headerlink" title="什么是后缀树？"></a>什么是后缀树？</h2><p>后缀树是一种搜索树，它描述了给定字符串的所有后缀，许多重要的字符串操作都能够在后缀树上快速地实现。</p><p><strong>定义</strong></p><p>一个长度为n的字符串S，它的后缀树定义为一棵满足如下条件的树：</p><ol><li><p>从根到树叶的路径与S的后缀一一对应。即每条路径惟一代表了S的一个后缀；</p></li><li><p>每条边都代表一个非空的字符串；</p></li><li><p>所有内部节点（根节点除外）都有至少两个子节点。</p></li></ol><h2 id="后缀树构建（Ukkonen"><a href="#后缀树构建（Ukkonen" class="headerlink" title="后缀树构建（Ukkonen)"></a>后缀树构建（Ukkonen)</h2><h2 id="需要明确的问题"><a href="#需要明确的问题" class="headerlink" title="需要明确的问题"></a>需要明确的问题</h2><p>​        （理论层面</p><ol><li><p>后缀树的定义是什么？</p></li><li><p>后缀树能够高效解决哪些问题？</p></li><li><p>边和点的含义是什么？</p></li><li><p>隐式树和显示树各是什么？</p></li><li><p>（实现层面</p></li><li><p>三元组（活跃节点、活跃半径、活跃边）代表什么？</p></li><li><p>后缀链表是什么？</p></li><li><p>加边的时候的三个规则</p></li><li><p>‘$‘符号的意义？能不能用其他的代替’$‘？</p></li><li><p>举例一个过程,abcabcxabc$</p></li></ol><h2 id="待更…"><a href="#待更…" class="headerlink" title="待更…"></a>待更…</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 后缀树 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> Ukkonen </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/05/07/hello-world/"/>
      <url>/2020/05/07/hello-world/</url>
      
        <content type="html"><![CDATA[<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h1 id="Hello-LS"><a href="#Hello-LS" class="headerlink" title="Hello LS"></a>Hello LS</h1><p>asdas</p><p>‘’’</p><p>asdas</p><p>‘’’</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
